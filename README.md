# Computer-Programming-2nd-Part
কম্পিউটার প্রোগ্রামিং ২য় খণ্ড (Tamim-Shahriar-Subeen) Book's Code

# Notes

## অধ্যায় ০০ - শুরুর আগে

## অধ্যায় ০১ - কম্পিউটার মেমোরি (Computer Memory)

### ১.১ - বিট ও বাইট
1. 0 আর 1 এগুলো হচ্ছে একেকটি bit
2. n টি bit থাকলে 2^n টি পথক জিনিস রাখা সম্ভব
3. 8bit = 1byte
4. ASCII value
5. Unicode
6. unsigned variable
7. signed variable

### ১.২ - ভ্যারিয়েবলের অ্যাড্রেস বা ঠিকানা
1. কম্পিউটারের মেমোরিতে ক্ষুদ্রতম একক হচ্ছে বাইট (byte)
2. variable address
3. কোনো ভ্যারিয়েবল যদি `n` হয়, তবে তার অ্যাড্রেস হচ্ছে `&n`
4. `sizeof` অপারেটর

### ১.৩ - বিভিন্ন প্রকারের মেমোরি
1. non volatile mamory (hard dirsk, ssd)
2. volatile (ram)
3. `register` key word

## অধ্যায় ০২ - পয়েন্টার (Pointer)

1. পয়েন্টার হচ্ছে একটি বিশেষ ধরনের ভ্যারিয়েবল যেটি আরেকটি ভ্যারিয়েবলের ঠিকানা রাখতে পারে।
2. যখন আমরা লিখি `int *p`, তখন একে পড়ি এভাবে, `integer pointer p`
3. যখন আমরা লিখি `*p`, তখন একে পড়ি এভাবে, `content of p`
4. `*p` ব্যবহার করে x-কে একসেস করার পদ্ধতিকে বলে ডিরেফারেন্সিং (dereferencing)

### ২.১ - নাল পয়েন্টার
1. যদি আমরা একটি পয়েন্টার কিক্লেয়ার করি, যেটি এই মুহূর্তে কোনো ভ্যারিয়েবলকে পয়েন্ট করছে না, তাহলে আমরা সেই পয়েন্টারে নাল (`NULL`) অ্যাসাইন করে দিতে পারি।
1. আমরা যখন * চিহ্ন ব্যবহার করে কোনো পয়েন্টােরে যেই মেমোরি অ্যাড্রেস লেখা আছে, সেই মেমোরি লোকেশনের মান অ্যাসেস করতে চাই তখন তাকে বলে ডিরেফারেন্সিং (dereferencing)। এখানে * কে বলা হয় ডিরেফারেন্সিং অপারেটর(Dereferencing Operator)।‌

### ২.২ - স্ট্রিং ও পয়েন্টার
1. অ্যারের নামটিই তার অ্যাড্রেস বা ঠিকানা নির্দেশ করে।

### ২.৩ - পয়েন্টারের পয়েন্টার

## অধ্যায় ০৩ - ফাইল(File)

1. একটি ফাইলের নামের তিনটি অংশ থাকে - ফাইলের নাম, একটি ডট (.) ও এক্সটেনশন (extension)
2. আমরা যখন ফাইল নিয়ে কাজ করি, তখন মূলত এই কাজগুলো করি।
   1. ফাইল ওপেন (File Open)
   2. ফাইল রিড (File Read)
   3. ফাইল রাইট (File Write)
   4. ফাইল ক্লোজ (File Close)
3. `FILE` কিন্তু ঠিক ইন্টিজার বা ডবলের মতো ডেটাটাইপ নয়, এটিকে বলে ফাইল হ্যান্ডেল (handle)
4. `fopen()` ফাংশন
5. ফাইল ওপেন করার মোড
   | মোড | বর্ণনা                                                        |
   | ---- | ------------------------------------------------------------ |
   | ‍`w`  | ফাইলে লেখার উদ্দেশ্য একটি ফাইল খোলা। যদি ফাইলটি না থাকে, তাহলে সেটি তৈরি করে নেয় |
   | `r`  | ফাইল পড়ার জন্য খোলা। অবশ্যই ফাইলটি কম্পিউটারে থাকতে হবে।       |
   | `a`  |                                                              |
   | `w+` |                                                              |
   | `r+` |                                                              |
   | `a+` |                                                              |
   | `rb` |                                                              |
   | `wb` |                                                              |
   | `ab` |                                                              |
6. `fprintf()` ফাংশন
7. `fclose()` ফাংশন
8. `fscanf()` ফাংশন
9. `fgets()` ফাংশন
10. `perror()` ফাংশন
11. `EXIT_FAILURE` and `EXIT_SUCCESS` macro in <stdlib.h> header file
12. `fgetc()` ফাংশন
13. `EOF` macro in <stdio.h> header file
14. `fputc()` ফাংশন
15. File Position Indictor
16. `fseek()` ফাংশন
17. `SEEK_SET`, `SEEK_CUR` and `SEEK_END` macro in <stdio.h> header file
18. `ftell()` ফাংশন
19. `fread()` and `fwrite` ফাংশন
20. `remove()` ফাংশন

## অধ্যায় ০৪ - রিকার্শন(Recursion)

### ৪.1 - লোকাল ও গ্লোবাল ভ্যারিয়েবল
1. গ্লোবাল ভ্যারিয়েবল ডিক্লেয়ার করার সময় কোনো মান অ্যাসাইন না করলে স্বয়ংক্রিয়ভাবে 0 অ্যাসাইন হয়, কিন্তু লোকাল ভ্যারিয়েবলের ক্ষেত্রে সেটি হয় না।
2. আর কোনো প্রোগ্রামে যদি একটি গ্লোবাল ভ্যারিয়েবল থাকে আর একই নামে কোনো ফাংশনে একটি লোকাল ভ্যারিয়েবল থাকে, তখন কিন্তু ওই ফাংশ আর গ্লোবাল ভ্যারিয়েবলটিকে চিনবে না, লোকাল ভ্যারিয়েবলকে চিনবে।

### ৪.২ - স্ট্যাটিক ভ্যারিয়েবল
1. `static` ভ্যারিয়েবল
2. গ্রোবাল ভ্যারিয়েবলগুলোকে যেকোন ফাইলের যেকোন ফাংশণ থেকে একসেস করা যায়। আর স্ট্যাটিক গ্লোবাল ভ্যারিয়েবলগুলোকে শুধুমাত্র যেই ফাইলে ডিক্লেয়ার করা হয়েছে ওই ফাইলের ফাংশনগুলোর মধ্যেই একসেস করা যাবে। 
3. ফাংশন মুছে গেলেও `static` লোকাল ভ্যারিয়েবল মুছে যায় না। ওটা মেমোরিতে থেকে যায়, যতক্ষন প্রোগ্রাম চলতে থাকে।

### ৪.৩ - বিভিন্ন প্রকারের মেমোরি
1. প্রোগ্রাম চালানোর সময় অপারেটিং সিস্টেম মেমোরিকে কয়েকটি ভাগে ভাগ করে। সেগুলো হচ্ছে - ‌
   1. code segment
   2. data seggment
   3. stack segment
   4. heap segment

### ৪.৪ - রিকার্শন
1. একটি ফাংশন থেকে যখন আরেকটি ফাংশন কল করা হয়, তখন কম্পিউটার যে ফাংশন থেকে কল করা হচ্ছে, সেই ফাংশনের ভ্যারিয়েবল এবং ফাংশনের কোন লাইন পর্যন্ত প্রোগ্রাম রান হয়েছিল, এসব তথ্য স্ট্যক মেমোরিতে রাখে। তাই বারবার কল হতে থাকলে স্ট্যাকের জন্য বরাদ্দ সব জায়গা শেষ হয়ে যায়, তাই প্রোগ্রামটি বন্ধ হয়ে যায়, একে ক্র্যাশ (crash) করাও বলে।
2. রিকার্শন হচ্ছে একটি ফাংশন নিজেই নিজেকে কল করা।
3. রিকার্শন মানে যে কেবল ফাংশন নিজেই নিজেকে কল করা, তা নয়। যদি এমন হয় যে একটি ফাংশন A থেকে আরেকটি ফাংশন B কল করা হচ্ছে, B থেকে C কল করা হচ্ছে, C আবার A-কে কল করছে - তাহলে এটিও রিকার্শনের মধ্যেই পরে।

## অধ্যায় ০৫ - বিটওয়াইজ অপারেশন(Bitwise Operation)

1. সি প্রোগ্রামিং ভাষায় ভ্যারিয়েবলেল ক্ষুদ্রতম একক হচ্ছে বাইট।
2. কিন্তু সি-তে চাইলে বিট নিয়ে কাজ করা যায়। বিভিন্ন ধরনের bitwise operator রের মাধ্যমে।

### Bitwise Not (`~`) Operator
1. Bitwise not (`~`) অপারেটর।
2. টুজ কমপ্লিমেন্ট (Two's complement) পদ্ধতি।
3. বিটওয়াইজ নট অপারেটরের কাজ হচ্ছে সবগুলো বিট উল্টে দেওয়া (1 হলে 0 আর 0 হলে 1)।

### Bitwise Shift (`<<` or `>>`) Operator
1. সি-তে দুই রকম শিফট অপারেটর আছে, লেফট শিফট অপারেটর (‍`<<`) এবং রাইট শিফট অপারেটর (‍‍‍`>>`)
2. শিফট অপারেটরের মাধ্যমে যে বিট সরিয়ে নেওয়া হয় সেগুলো সব 0 বিট দিয়ে পূর্ণ হবে।
3. কোনো সংখ্যাকে এক ঘর লেফট শিফট করা মানে তাকে 2 দিয়ে গুণ করা আর এক ঘর রাইট শিফট করা মানে 2 দিয়ে ভাগ করা।
4. `n` সংখ্যাকে `x` ঘর লেফট শিফট করলে, যদি `s` সংখ্যা পাওয়া যায়। তবে, `s = n * (2^x) = n << x`
5. `n` সংখ্যাকে `x` ঘর রাইট শিফট করলে, যদি `s` সংখ্যা পাওয়া যায়। তবে, `s = n / (2^x) = n >> x`

### Bitwise And (`&`), Or (`|`) এবং xor বা exclusive or (‍`^`) Operator

1. বিটওয়াইজ And (`&`) ক্ষেত্রে কেবল দুটিই বিট যদি 1 হয়, তাহলে আউটপুট হবে 1 আর অন্য সব ক্ষেত্রে আউটপুট হবে 0
2. বিটওয়াইজ Or (`|`) ক্ষেত্রে কেবল দুটিই বিট যদি 0 হয়, তাহলে আউটপুট হবে 0 আর অন্য সব ক্ষেত্রে আউটপুট হবে 1
3. বিটওয়াইজ Xor (`|`) ক্ষেত্রে যদি যেকোনো একটি রিট 1 এবং অপর বিটটি 0 হয়, তখন আউটপুট হবে 1, আর দুটিই যদি 1 হয় কিংবা দুটিই যদি 0 হয় তাহলে আউটপুট হবে 0
4. `CHAR_BIT` macro in <limits.h> header file

## অধ্যায় ০৬ - স্ট্রাকচার(Structure) ও ইউনিয়ন(Union)

### ৬.১ - স্ট্রাকচার (Sturcture)
1. `sturct` 
2. `typedef`
3. কল বাই ভ্যালু (call by value)
4. কল বাই রেফারেন্স (call by reference)
5. call by reference in structure
6. Function with Structure

### ৬.2 - ইউনিয়ন (Union)
1. ইউনিয়ন অনেকটা স্ট্রাকচারের মতোই তবে স্ট্রাকচারের সঙ্গে পার্থক্য হচ্ছে, ইউনিয়ন ভ্যারিয়েবল, ইউনিয়নের ভেতরের যেকোনো একটিমাত্র সদস্য নিয়ে কাজ করতে পারে। কারণ সদস্যগুলো একই মেমোরি শেয়ার করে।
2. এমবেডেড প্রোগ্রামিংয়ে (embedded programming) এটি ব্যবহার করা হয়।

### ৬.৩ - স্ট্রাকচারের মেমোরি অ্যালাইমেন্ট
1. এক: কেউ স্ট্রাকচারে সাইজ জিজ্ঞাসা করলে হুট করে উত্তর দেবে না, হিসাব-নিকাশ করে উত্তর দেবে।
2. দুই: স্ট্রাকচারে মেম্বার ভ্যারিয়েবলগুলো সবসময় সাইজ অনুসারে ছোট থেকে বড় ক্রমে ডিক্লেয়ার করবে। তাহলে কম মেমোরি খরচ হবে।

## অধ্যায় ০৭ - আরও পয়েন্টার

### ডায়নামিক মেমোরি অ্যালোকোশন (dynamic memory allocation)
1. `malloc()` ফাংশন ব্যবহার করে মেমোরি অ্যালোকেট করা।
2. ‍malloc() ফাংশন দিয়ে মেমোরি অ্যালোকেট করলে সেটি কম্পিউটার মেমোরির যে অংশে থাকে, তার না হচ্ছে হিপ(heap) সেগমেন্ট।
3. মেমোরি লিক (memory leak)
4. `free()` ফাংশন ব্যবহার করে মেমোরি ফ্রি করা।
5. `calloc()` ফাংশন

### ৭.১ - পয়েন্টারের হিসাব-নিকাশ
1. যদি p পয়েন্টার হয়, তবে p+1 করলে p এর মান কত বাড়বে সেটি নির্ভর করবে p কোন টাইপের ভ্যারিয়েবলকে পয়েন্ট করে তার ওপর।

### ৭.২ - ভয়েড পয়েন্টার (void pointer)
1. ptr যদি ভয়েড পয়েন্টার হয় এবং এটি যদি integer কে পয়েন্ট করে, তবে ptr-কে ডিরেফারেন্স করতে চাই, তাহলে *ptr লিখলে হবে না, আমাদের টাইপ কাস্ট করে নিতে হবে, এভাবে: `*((int *) prt)`

### ৭.৩ - ফাংশন পয়েন্টার
1. ফাংশন পয়েন্টার ব্যবহার করার একটি বড় সুবিধা হচ্ছে, এটি দিয়ে ফাংশনকে আরেকটি ফাংশনেন প্যারামিটার হিসেবে পাঠানো যায়।
2. ফাংশনের নামটিই তার ঠিকানা হিসেবে ব্যবহার করা যায়। fun যদি ফাংশন হয়, তবে `fun = &fun`

### ৭.৪ - qsort() ও bsearch ফাংশন
1. `const` কি-ওর্য়াড। const অর্থ হচ্ছে যেই মানগুলো আমরা পাঠার, সেগুলো পরিবর্তন করা হবে না।
2. `qsort()` ফাংশন
3. `bsearch()` ফাংশন

## অধ্যায় ০৮ - মজার কিছু প্রোগ্রাম (Some interesting program)

### ৮.১ - সময় পরিমাপ
1. <time.h> header file
2. `clock_t` Variable type in <time.h>
3. `clock()` ফাংশন
4. `CLOCKS_PER_SEC` macro in <time.h>

### ৮.২ - Random number
1. `rand()` ফাংশন
2. `time_t` Variable type <time.h>
3. `srand()` ফাংশন
4. `time()` ফাংশন

### ৮.৩ - নিজে হেডার ফাইল তৈরি করা

## অধ্যায় ০৯ - বিবিধ

### ৯.১ - কনস্ট্যান্ট(constant), ম্যাক্রো (Macro) এবং টার্নারি অপারেটর
1. constant using #define
2. macro using #define
3. টার্নারি অপারেটর `কন্ডিশন? স্টেটমেন্ট 1 : স্টেটমেন্ট 2` | কন্ডিশন যদি সত্য হয়, তাহলে স্টেটমেন্ট 1 কাজ করবে, আর সত্য না হলে স্টেটমেন্ট ২

### ৯.২ - এনিউমারেশন (enumeration)
1. `enum`
2. `switch` statement

### ৯.3 - কমান্ড লাইন আর্গুমেন্ট (Command Line Argument)
1. `int argc, char *argv[]` argument in main() function
2. convert str into int use `atoi()` function

### ৯.৪ - প্রোগ্রাম কম্পাইল হওয়ার ধাপসমূহ
1. সি প্রোগ্রাম কম্পাইল হওয়ার সময় মোট চারটি কাজ হয়:
   1. প্রিপ্রসেসিং (Preprocessing)
   2. কম্পাইল (Compile)
   3. অ্যাসেম্বলি (Assembly)
   4. লিঙ্কিং (Linking)
2. Preprocesser: Preprocesser remove comments and include header files in source code, replace macro name with code.
3. Compiler: Compiler generate assembly code .
4. Assembler: Assembler conbert assemble code into object code or binary code.
5. Linker: Linker combine all the object code and make one executable code (in window `.exe` or linux `a.out`)

### ৯.৫ - typedef ও #define নিয়ে কিছু কথা
1. `#define` is preprocesser
2. `typedef` is a keyword
3. typedef  অন্যান্য ভ্যারিয়েবলের মতো স্কোপিং নীতি মেনে চলে যেখানে #define এর কােনো স্কোপিং নীতি নেই। যেখানে ডিফাইন করা হয় তার পরে থেকে যেকোনো জায়গায় ব্যবহার করা যায়।

### ৯.৬ - main() ফাংশন ও return 0
1. ISO C90 অনুসারে এই তিনটি উপায়ে main() ফাংশন ডিক্লেয়ার করা যাবে
   ```c
   int main(void)
   int main(int argc, char **argv)
   int main(int argc, char *argb[])
   ```
2. main() ফাংশন return করার আদর্শ নীতিমালা
   ```c
   0
   EXIT_SUCCESS
   EXIT_FAILURE
   ```
3. ISO C99 আদর্শ নীতিমালা অনুসারে
   1. main() ফাংশনের ডিক্লেয়ারেশনে int শব্দটি অবশ্যই উল্লেখ করতে হবে।
   2. return 0  কথাটি চাইলে বাদ দেওয়া যাবে। যদি এই লাইনটি না লেখা হয় ডিফল্ট হিসেবে main() ফাংশন এক্সিকিউশনের শেষে 0 রিটির্ন করা হবে।
4. main() ফাংশন return করার আর্দশ নিয়ম
   1. প্রোগ্রাম ঠিকভাবে চলে এক্সিট করলে 0 রিটার্ন করা
   2. প্রােগ্রাম চলাকালে কোনো এরর হয়ে যদি প্রোগ্রামটি মধ্যপথেই বন্ধ হয়ে যায় তাহলে, 0 ছাড়া যেকোন মান রিটার্ন করা।

### ৯.৭ - lvalue এবং rvalue
1. এক্সপ্রেশন লিখতে হলে সমান চিহ্নের বামে যে অংশটি থাকে বলে এলভ্যালু (lvalue)
2. এক্সপ্রেশন লিখতে হলে সমান চিহ্নের ডানে যে অংশটি থাকে বলে আরভ্যালু (lvalue)
3. এলভ্যালু সেই সব এক্সপ্রেশন যাদের একটি মেমোরি লোকেশন থাকে এবং সেই লোকেশনের কোনো একটি মানকে অ্যাসাইন করা যায়। এদের যেহেতু মেমোরি লোকেশন থাকে সেহেতু এদের একটি মানও থাকে।
4. আরভ্যালু হচ্ছে সেই সয় এক্সেপ্রেশন যাদের একটি মান থাকে। এদেরও একটি মেমোরি লোকেশন থাকে, কেননা সব মানই তো কোনো না কোনো মেমোরি লোকেশনেই আছে। তবে এই মেমোরি লোকেশন কোনো ভ্যারিয়েবলকে নির্দেশ করে না এবং এখানে কোনো মান অ্যাসাইন করা যায় না।

## অধ্যায় ১০ - প্রোগ্রাম ডিবাগিং

### ১০.1 - ডিবাগিং (Debugging)

### ১০.2 - সাধারণ ডিবাগিং

### ১০.3 - কোডব্লকসে ডিবাগিং

## অধ্যায় ১১ - যেতে হবে বহুদূর
1. এখন দুটি জিনিস শেখা যাবে:
   1. অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিং:
      1. অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিং শেখার জন্য ছয় মাস থেকে এক বছর নিরলস পরিশ্রম ও অধ্যাবসায়ের প্রয়োজন হবে।
      2. প্রোগ্রামিং প্রতিযোগিতায় অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিংয়ের তেমন গুরুত্ব না থাকলেও দক্ষ সফটওয়্যার প্রকৌশলী হওয়ার পূর্বর্শর্ত হচ্ছে অবজেক্ট ওরিয়েন্টেড প্রোগ্রামিংয়ে দক্ষতা।
   2. ডেটা স্ট্রাকচার ও অ্যালগরিদম:
      1. ডেটা স্ট্রাকচার ও অ্যালগরিদম শেখার জন্য় একটুখানি বিচ্ছিন্ন গণিত (ডিসক্রিট ম্যাথ) শিখে নিতে হবে।
      2. ডেটা স্ট্রাকচার ও অ্যালগরিদম শেখার জন্য প্রায় দেড় থেকে দুই বছর নিরলস পরিশ্রম ও অধ্যাবসায়ের প্রয়োজন হবে।
